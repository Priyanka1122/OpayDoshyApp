import { Platform, useWindowDimensions, StyleSheet, View, Text, Image, ScrollView, FlatList, SectionList, TouchableOpacity, TextInput, SafeAreaView } from 'react-native';
import React, { createContext, useContext, useMemo, memo, forwardRef } from 'react';
import { getStylesForProperty, getPropertyName } from 'css-to-react-native';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var colorAttributes = /*#__PURE__*/new Set(['backgroundColor', 'color', 'borderRightColor', 'borderBottomColor', 'borderColor', 'borderEndColor', 'borderLeftColor', 'backgroundColor', 'borderStartColor', 'borderTopColor', 'shadowColor', 'textDecorationColor']);
var lengthAttributes = /*#__PURE__*/new Set(['width', 'height', 'borderBottomEndRadius', 'borderBottomLeftRadius', 'borderBottomRightRadius', 'borderBottomStartRadius', 'borderBottomWidth', 'borderLeftWidth', 'borderRadius', 'borderRightWidth', 'borderTopEndRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderTopStartRadius', 'borderTopWidth', 'borderWidth', 'flexBasis', 'bottom', 'end', 'left', 'right', 'start', 'top', 'margin', 'marginBottom', 'marginEnd', 'marginHorizontal', 'marginLeft', 'marginRight', 'marginStart', 'marginTop', 'marginVertical', 'maxHeight', 'maxWidth', 'minHeight', 'minWidth', 'padding', 'paddingBottom', 'paddingEnd', 'paddingHorizontal', 'paddingLeft', 'paddingRight', 'paddingStart', 'paddingTop', 'paddingVertical', 'shadowOffset', 'shadowRadius', 'lineHeight', 'fontSize', 'letterSpacing']);

var ThemeContext = /*#__PURE__*/createContext(null);
var setThemeContext = function setThemeContext(ExternalThemeContext) {
  ThemeContext = ExternalThemeContext;
};
var useTheme = function useTheme() {
  var theme = useContext(ThemeContext);
  if (!theme) throw new Error('missing theme context, wrap your app in a ThemeProvider');
  return theme;
};
var withTheme = function withTheme(Component) {
  var ComponentWithTheme = function ComponentWithTheme(props) {
    var theme = useTheme();
    return React.createElement(Component, Object.assign({}, props, {
      theme: theme
    }), props.children || null);
  };

  ComponentWithTheme.displayName = "WithTheme(" + (Component.displayName || Component.name) + ")";
  return ComponentWithTheme;
};
var ThemeProvider = function ThemeProvider(_ref) {
  var theme = _ref.theme,
      children = _ref.children,
      rootCss = _ref.rootCss,
      _ref$rootFont = _ref.rootFont,
      rootFont = _ref$rootFont === void 0 ? '-apple-system, Roboto, sans-serif' : _ref$rootFont,
      _ref$rootBackgroundCo = _ref.rootBackgroundColor,
      rootBackgroundColor = _ref$rootBackgroundCo === void 0 ? 'white' : _ref$rootBackgroundCo,
      _ref$disableOutlines = _ref.disableOutlines,
      disableOutlines = _ref$disableOutlines === void 0 ? true : _ref$disableOutlines;
  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
  // @ts-ignore cannot add colors to ThemeInterface because we don't want to restrict it
  var colors = theme.colors;
  var backgroundColor = rootBackgroundColor.substring(0, 1) === '$' ? colors[rootBackgroundColor.substring(1)] : rootBackgroundColor;
  return React.createElement(ThemeContext.Provider, {
    value: theme
  }, React.createElement(React.Fragment, null, Platform.OS === 'web' ? React.createElement("style", {
    // eslint-disable-next-line react-perf/jsx-no-new-object-as-prop
    dangerouslySetInnerHTML: {
      __html: "\n                html, body, #root {\n                  font-family: " + rootFont + ";\n                  min-height: 100%;\n                  background: " + backgroundColor + ";\n                  font-size: " + theme.rem + "px;\n                }\n                #root { display: flex; }\n                " + (disableOutlines ? 'textarea, select, input { outline: none; }' : '') + "\n                " + (rootCss || '') + "\n              "
    },
    key: "global_style"
  }) : null, children));
}; // css-to-react-native only supports proper css color values, so we resolve color variables to transparent hex values when compiling the template strings and then transform them back and dynamically resolve them from the theme when rendering

var currentColorId = 1;
var themeColors = {
  hexForVarName: /*#__PURE__*/new Map([]),
  nameForHex: /*#__PURE__*/new Map([])
};
var resolveColorVariablePlaceholder = function resolveColorVariablePlaceholder(variableName) {
  if (!themeColors.hexForVarName.has(variableName)) {
    var hexPlaceholder = "#" + (currentColorId++).toString(16).padStart(6, '0').toUpperCase() + "00";
    themeColors.hexForVarName.set(variableName, hexPlaceholder);
    themeColors.nameForHex.set(hexPlaceholder, variableName.substring(1));
  }

  return themeColors.hexForVarName.get(variableName);
}; // resolve any occurences of theme variables in the values of a style object

var plattformIsWeb = Platform.OS === 'web';
var resolveLengthUnit = function resolveLengthUnit(str, theme, windowDimensions) {
  if (!str || typeof str === 'number') return str;
  if (typeof str !== 'string') throw new Error("expected " + str + " to be a string");
  var value = Number.parseFloat(str);
  if (value === 0) return 0;
  var unit = str.trim().replace(String(value), '');
  if (!unit) throw new Error("length string '" + str + "' contains no unit");

  switch (unit) {
    case 'rem':
      return value * theme.rem;

    case 'px':
      return value;

    case '%':
      return str;

    case 'vw':
      return value * windowDimensions.width / 100;

    case 'vh':
      return value * windowDimensions.height / 100;

    default:
      throw new Error("cannot parse length string '" + str + "', unknown unit '" + unit + "'");
  }
};
var resolveThemeVariables = function resolveThemeVariables(styleObject, theme, windowDimensions) {
  for (var key in styleObject) {
    if (key === 'elevation' && theme.elevation) {
      var shadowStyleObject = theme.elevation(styleObject[key]);

      for (var shadowKey in shadowStyleObject) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore typescript doesn't understand that we are assigning the same keys here
        styleObject[shadowKey] = shadowStyleObject[shadowKey];
      }
    }

    if (key === 'cursor' && !plattformIsWeb) delete styleObject.cursor; // resolve all color names to theme variables if possible

    if (colorAttributes.has(key)) {
      var colorName = themeColors.nameForHex.get(styleObject[key]);

      if (colorName) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore cannot add colors to ThemeInterface because we don't want to restrict it
        var colors = theme.colors;

        if (colorName in colors) {
          styleObject[key] = colors[colorName];
        } else {
          throw new Error("the color variable '$" + colorName + "' has not been defined in the theme.");
        }
      }
    } // resolve all rem and viewport units unless on web where they are supported natively


    if (!plattformIsWeb && lengthAttributes.has(key) && typeof styleObject[key] === 'string') {
      styleObject[key] = resolveLengthUnit(styleObject[key], theme, windowDimensions);
    }
  }

  return styleObject;
};

var cssCommentRegexp = /*#__PURE__*/new RegExp('\\/\\*[^]+?\\*\\/', 'g');

var resolveTemplateLiteral = function resolveTemplateLiteral(strings, expressions, props) {
  return strings.map(function (str, i) {
    // resolve expressions
    var exp = expressions.length > i ? expressions[i] : '';

    if (typeof exp === 'string' || typeof exp === 'number') {
      return str + exp;
    } else {
      return str + exp(props);
    }
  }).join('') // remove comments
  .replace(cssCommentRegexp, '');
}; // create a RN style object from a single css declaration


var variableRegexp = /*#__PURE__*/new RegExp('\\$[\\w|-]+', 'g');
var styleObjectCache = /*#__PURE__*/new Map([]);

var createStyleObject = function createStyleObject(cssDeclaration) {
  if (!cssDeclaration) return {};
  var styleObject = styleObjectCache.get(cssDeclaration);

  if (!styleObject) {
    styleObject = Object.assign.apply(Object, [{}].concat(cssDeclaration.split(';').map(function (rule) {
      return rule.split(':').map(function (value) {
        return value && value.trim();
      }).filter(function (value) {
        return value;
      });
    }).filter(function (rule) {
      return rule.length === 2;
    }).map(function (_ref) {
      var name = _ref[0],
          value = _ref[1];
      var resolvedValue = value.replace(variableRegexp, function (variable) {
        return resolveColorVariablePlaceholder(variable);
      });

      try {
        return getStylesForProperty(getPropertyName(name), resolvedValue);
      } catch (e) {
        throw new Error("could not parse '" + name + ": " + value + "'\n" + e.message);
      }
    })));
    styleObjectCache.set(cssDeclaration, styleObject);
  }

  return styleObject;
};

var nestedStyleObjectsCache = /*#__PURE__*/new Map([]); // create an object of RN style objects for each media query from a single css declaration

var createNestedStyleObject = function createNestedStyleObject(cssDeclaration) {
  var nestedStyleObject = nestedStyleObjectsCache.get(cssDeclaration);

  if (!nestedStyleObject) {
    nestedStyleObject = {
      style: {
        main: {}
      }
    };
    var match;
    var start = 0;
    var name;
    var nOpen = 0;
    var mainDeclaration = '';
    var braceRegExp = new RegExp('\\s*.+\\s*\\{|\\}', 'g');

    while (match = braceRegExp.exec(cssDeclaration)) {
      if (nOpen === 0) {
        mainDeclaration += cssDeclaration.substring(start, match.index);
        start = match.index + match[0].length;
        name = cssDeclaration.substring(match.index, match.index + match[0].length - 1).trim();
      }

      nOpen = nOpen + (match[0] === '}' ? -1 : +1);

      if (nOpen === 0) {
        var declaration = cssDeclaration.substring(start, match.index).trim();
        start = match.index + 1;

        if (name.substring(0, 6) === '@media') {
          nestedStyleObject.style[name.substring(6).trim()] = createStyleObject(declaration);
        } else {
          nestedStyleObject[name + 'Style'] = createNestedStyleObject(declaration).style;
        }
      }
    }

    mainDeclaration += cssDeclaration.substring(start, cssDeclaration.length);
    nestedStyleObject.style.main = createStyleObject(mainDeclaration.trim());
    nestedStyleObjectsCache.set(cssDeclaration, nestedStyleObject);
  }

  return nestedStyleObject;
};

var matchMediaRule = function matchMediaRule(mediaRule, theme, windowDimensions) {
  var matched = true;

  for (var _iterator = _createForOfIteratorHelperLoose(mediaRule.split('and')), _step; !(_step = _iterator()).done;) {
    var condition = _step.value;

    var _condition$replace$tr = condition.replace(/\(|\)/g, '').trim().split(':'),
        name = _condition$replace$tr[0],
        strVal = _condition$replace$tr[1];

    var value = resolveLengthUnit(strVal, theme, windowDimensions);
    if (typeof value !== 'number') throw new Error("invalid unit on @media " + mediaRule);
    var width = windowDimensions.width,
        height = windowDimensions.height;

    switch (name) {
      case 'min-width':
        matched = matched && width >= value;
        break;

      case 'max-width':
        matched = matched && width <= value;
        break;

      case 'min-height':
        matched = matched && height >= value;
        break;

      case 'max-height':
        matched = matched && height <= value;
        break;
    } // console.log('matching', condition, value, windowDimensions, matched);

  }

  return matched;
}; // generate styleSheet from nested style Object with media queries


var useStyleSheet = function useStyleSheet(styles, theme, windowDimensions) {
  return useMemo(function () {
    var finalStyles = {}; // we need to make sure to do a deep clone here, so that theme and viewport units can be resolved from original strings

    var stylesCopy = _extends({}, styles);

    for (var key in stylesCopy) {
      var _stylesCopy$key = stylesCopy[key],
          main = _stylesCopy$key.main,
          mediaStylesCopy = _objectWithoutPropertiesLoose(_stylesCopy$key, ["main"]); // this will contain the main style and all applicapble media query styles


      var mediaStylesArray = [resolveThemeVariables(_extends({}, main), theme, windowDimensions)];

      for (var mediaRule in mediaStylesCopy) {
        if (matchMediaRule(mediaRule, theme, windowDimensions)) {
          mediaStylesArray.push(resolveThemeVariables(_extends({}, mediaStylesCopy[mediaRule]), theme, windowDimensions));
        }
      }

      finalStyles[key] = Object.assign.apply(Object, [{}].concat(mediaStylesArray));
    }

    return StyleSheet.create(finalStyles);
  }, [styles, theme, windowDimensions]);
};

var makeTemplateFunction = function makeTemplateFunction(Component, transformProps, filterComponentProps) {
  return function (strings) {
    for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      expressions[_key - 1] = arguments[_key];
    }

    var displayName = "Styled(" + (Component.displayName || Component.name) + ")";
    var StyledForwardRefRenderFunction;

    if (expressions.every(function (exp) {
      return typeof exp === 'string';
    })) {
      // if no props are used in the styles, then we can statically generate the cssString
      var cssString = resolveTemplateLiteral(strings, expressions);
      var styles = createNestedStyleObject(cssString);

      StyledForwardRefRenderFunction = function StyledForwardRefRenderFunction( // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore ts doesn't understand that A is not allwoed to declar children and style
      _ref2, ref) {
        var children = _ref2.children,
            style = _ref2.style,
            props = _objectWithoutPropertiesLoose(_ref2, ["children", "style"]);

        var theme = useTheme();
        var dimensions = useWindowDimensions();
        var styleProps = useStyleSheet(styles, theme, dimensions);
        styleProps = style ? _extends({}, styleProps, {
          style: [styleProps.style, style]
        }) : styleProps;
        var transformedProps = transformProps(_extends({}, props, {
          theme: theme
        }));
        return React.createElement(Component, Object.assign({}, filterComponentProps(transformedProps), styleProps, {
          ref: ref
        }), children);
      };
    } else {
      // if the cssString depends on props, we can at least ignore changes to children
      StyledForwardRefRenderFunction = function StyledForwardRefRenderFunction( // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore ts doesn't understand that A is not allwoed to declar children and style
      _ref3, ref) {
        var children = _ref3.children,
            style = _ref3.style,
            props = _objectWithoutPropertiesLoose(_ref3, ["children", "style"]);

        var theme = useTheme();
        var dimensions = useWindowDimensions();
        var transformedProps = transformProps(_extends({}, props, {
          theme: theme
        }));
        var cssString = useMemo(function () {
          return resolveTemplateLiteral(strings, expressions, transformedProps);
        }, [transformedProps]);
        var styles = useMemo(function () {
          return createNestedStyleObject(cssString);
        }, [cssString]);
        var styleProps = useStyleSheet(styles, theme, dimensions);
        styleProps = style ? _extends({}, styleProps, {
          style: [styleProps.style, style]
        }) : styleProps;
        return React.createElement(Component, Object.assign({}, filterComponentProps(transformedProps), styleProps, {
          ref: ref
        }), children);
      };
    }

    StyledForwardRefRenderFunction.displayName = displayName; // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
    // @ts-ignore ts gets confused in HOC wrappers but the declared return type has the proper refs

    return memo(forwardRef(StyledForwardRefRenderFunction));
  };
};
var useStyle = function useStyle(cssDeclaration) {
  var theme = useTheme();
  var dimensions = useWindowDimensions();
  var styles = useMemo(function () {
    return createNestedStyleObject(cssDeclaration.trim());
  }, []);
  return useStyleSheet(styles, theme, dimensions).style;
};

var useLengthAttribute = function useLengthAttribute(margin) {
  var theme = useTheme();
  var windowDimensions = useWindowDimensions();
  return useMemo(function () {
    var parsedMargin = margin.replace(/\s\s+/g, ' ').split(' ');
    var pixelValues = parsedMargin.map(function (str) {
      return resolveLengthUnit(str, theme, windowDimensions);
    });
    return [0, 1, 2, 3].map(function (i) {
      return pixelValues[i] !== undefined ? pixelValues[i] : pixelValues[i - 2] !== undefined ? pixelValues[i - 2] : pixelValues[0] || 0;
    });
  }, [margin, theme, windowDimensions]);
};
var useColorAttribute = function useColorAttribute(color) {
  var theme = useTheme(); // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
  // @ts-ignore cannot add colors to ThemeInterface because we don't want to restrict it

  var colors = theme.colors;
  return color in colors ? colors[color] : color && color.substring(1) in colors ? colors[color.substring(1)] : color;
};

var accessibilityPropNames = ['accessible', 'accessibilityActions', 'accessibilityLabel', 'accessibilityRole', 'accessibilityState', 'accessibilityHint', 'accessibilityValue', 'onAccessibilityAction', 'accessibilityComponentType', 'accessibilityLiveRegion', 'importantForAccessibility', 'accessibilityElementsHidden', 'accessibilityTraits', 'accessibilityViewIsModal', 'onAccessibilityEscape', 'onAccessibilityTap', 'onMagicTap', 'accessibilityIgnoresInvertColors']; // this ensures that we get typescript errors if a key from ViewProps is missing

var accessibilityPropNamesWithEnsuredCompleteKeys = accessibilityPropNames;
var viewPropNames = /*#__PURE__*/['style'].concat(accessibilityPropNamesWithEnsuredCompleteKeys, ['onStartShouldSetResponder', 'hitSlop', 'nativeID', 'onLayout', 'onMoveShouldSetResponder', 'onMoveShouldSetResponderCapture', 'onResponderGrant', 'onResponderMove', 'onResponderReject', 'onResponderRelease', 'onResponderTerminate', 'onResponderTerminationRequest', 'onStartShouldSetResponderCapture', 'pointerEvents', 'removeClippedSubviews', 'testID', 'collapsable', 'needsOffscreenAlphaCompositing', 'renderToHardwareTextureAndroid', 'shouldRasterizeIOS', 'focusable', 'isTVSelectable', 'hasTVPreferredFocus', 'tvParallaxProperties', 'tvParallaxShiftDistanceX', 'tvParallaxShiftDistanceY', 'tvParallaxTiltAngle', 'tvParallaxMagnification', 'onResponderEnd', 'onResponderStart', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel', 'onTouchEndCapture']); // this ensures that we get typescript errors if a key from ViewProps is missing

var viewPropNamesWithEnsuredCompleteKeys = viewPropNames;
var viewProps = /*#__PURE__*/new Set(viewPropNamesWithEnsuredCompleteKeys);
var textPropNames = /*#__PURE__*/['style'].concat(accessibilityPropNamesWithEnsuredCompleteKeys, ['selectable', 'ellipsizeMode', 'nativeID', 'numberOfLines', 'onLayout', 'onLongPress', 'onPress', 'pressRetentionOffset', 'allowFontScaling', 'testID', 'disabled', 'selectionColor', 'textBreakStrategy', 'adjustsFontSizeToFit', 'minimumFontScale', 'suppressHighlighting', 'pointerEvents', 'lineBreakMode', 'maxFontSizeMultiplier']); // this ensures that we get typescript errors if a key from ViewProps is missing

var textPropNamesWithEnsuredCompleteKeys = textPropNames;
var textProps = /*#__PURE__*/new Set(textPropNamesWithEnsuredCompleteKeys);
var imagePropNames = /*#__PURE__*/['style'].concat(accessibilityPropNamesWithEnsuredCompleteKeys, ['blurRadius', 'onLayout', 'onLoad', 'onLoadEnd', 'onLoadStart', 'resizeMode', 'source', 'loadingIndicatorSource', 'onError', 'testID', 'resizeMethod', 'capInsets', 'defaultSource', 'onPartialLoad', 'onProgress', 'fadeDuration', 'pointerEvents', 'progressiveRenderingEnabled']); // this ensures that we get typescript errors if a key from ViewProps is missing

var imagePropNamesWithEnsuredCompleteKeys = imagePropNames;
var imageProps = /*#__PURE__*/new Set(imagePropNamesWithEnsuredCompleteKeys);
var listPropNames = /*#__PURE__*/[].concat(viewPropNamesWithEnsuredCompleteKeys, ['columnWrapperStyle', 'contentContainerStyle', 'indicatorStyle'], accessibilityPropNamesWithEnsuredCompleteKeys, ['renderItem', 'data', 'sections', 'ItemSeparatorComponent', 'ListEmptyComponent', 'ListFooterComponent', 'ListHeaderComponent', 'extraData', 'getItemLayout', 'horizontal', 'initialNumToRender', 'initialScrollIndex', 'inverted', 'keyExtractor', 'numColumns', 'onEndReached', 'onEndReachedThreshold', 'onRefresh', 'onViewableItemsChanged', 'progressViewOffset', 'legacyImplementation', 'refreshing', 'viewabilityConfig', 'viewabilityConfigCallbackPairs', 'renderSectionFooter', 'renderSectionHeader', 'SectionSeparatorComponent', 'stickySectionHeadersEnabled', 'updateCellsBatchingPeriod', 'windowSize', 'disableVirtualization', 'getItem', 'getItemCount', 'debug', 'CellRendererComponent', 'onScrollToIndexFailed', 'renderScrollComponent', 'maxToRenderPerBatch', 'alwaysBounceVertical', 'keyboardDismissMode', 'keyboardShouldPersistTaps', 'onContentSizeChange', 'onMomentumScrollBegin', 'onMomentumScrollEnd', 'onScroll', 'onScrollBeginDrag', 'onScrollEndDrag', 'pagingEnabled', 'refreshControl', 'scrollEnabled', 'showsHorizontalScrollIndicator', 'showsVerticalScrollIndicator', 'stickyHeaderIndices', 'endFillColor', 'overScrollMode', 'scrollPerfTag', 'alwaysBounceHorizontal', 'automaticallyAdjustContentInsets', 'bounces', 'bouncesZoom', 'canCancelContentTouches', 'centerContent', 'contentInset', 'contentInsetAdjustmentBehavior', 'contentOffset', 'decelerationRate', 'directionalLockEnabled', 'maximumZoomScale', 'minimumZoomScale', 'pinchGestureEnabled', 'scrollEventThrottle', 'scrollIndicatorInsets', 'scrollsToTop', 'snapToAlignment', 'snapToInterval', 'snapToOffsets', 'snapToStart', 'snapToEnd', 'zoomScale', 'nestedScrollEnabled', 'listKey', 'invertStickyHeaders', 'disableIntervalMomentum', 'disableScrollViewPanResponder', 'onScrollAnimationEnd', 'scrollToOverflowEnabled', 'onScrollToTop', 'fadingEdgeLength', 'persistentScrollbar']); // this ensures that we get typescript errors if a key from ViewProps is missing

var listPropNamesWithEnsuredCompleteKeys = listPropNames;
var listProps = /*#__PURE__*/new Set(listPropNamesWithEnsuredCompleteKeys);
var inputPropNames = /*#__PURE__*/[].concat(viewPropNamesWithEnsuredCompleteKeys, accessibilityPropNamesWithEnsuredCompleteKeys, ['allowFontScaling', 'autoCapitalize', 'autoCorrect', 'autoFocus', 'blurOnSubmit', 'caretHidden', 'clearButtonMode', 'clearTextOnFocus', 'contextMenuHidden', 'dataDetectorTypes', 'defaultValue', 'disableFullscreenUI', 'editable', 'enablesReturnKeyAutomatically', 'inlineImageLeft', 'inlineImagePadding', 'keyboardAppearance', 'keyboardType', 'maxLength', 'multiline', 'numberOfLines', 'onBlur', 'onChange', 'onChangeText', 'onContentSizeChange', 'onEndEditing', 'onFocus', 'onKeyPress', 'onScroll', 'onSelectionChange', 'onSubmitEditing', 'placeholder', 'placeholderTextColor', 'returnKeyLabel', 'returnKeyType', 'scrollEnabled', 'secureTextEntry', 'selection', 'selectionColor', 'selectionState', 'selectTextOnFocus', 'spellCheck', 'textContentType', 'textBreakStrategy', 'underlineColorAndroid', 'value', 'maxFontSizeMultiplier', 'onTextInput', 'inputAccessoryViewID', 'passwordRules', 'rejectResponderTermination', 'autoCompleteType', 'importantForAutofill', 'textAlignVertical', 'showSoftInputOnFocus']); // this ensures that we get typescript errors if a key from ViewProps is missing

var inputPropNamesWithEnsuredCompleteKeys = inputPropNames;
var inputProps = /*#__PURE__*/new Set(inputPropNamesWithEnsuredCompleteKeys);
var pressablePropNames = /*#__PURE__*/[].concat(viewPropNamesWithEnsuredCompleteKeys, accessibilityPropNamesWithEnsuredCompleteKeys, ['delayLongPress', 'delayPressIn', 'delayPressOut', 'disabled', 'onBlur', 'onFocus', 'onLongPress', 'onPress', 'onPressIn', 'onPressOut', 'pressRetentionOffset', 'activeOpacity', 'children', 'android_disableSound', 'android_ripple', 'testOnly_pressed', 'touchSoundDisabled']); // this ensures that we get typescript errors if a key from ViewProps is missing

var pressablePropNamesWithEnsuredCompleteKeys = pressablePropNames;
var pressableProps = /*#__PURE__*/new Set(pressablePropNamesWithEnsuredCompleteKeys);
var domProps = /*#__PURE__*/new Set(['allowFullScreen', 'autoComplete', 'autoFocus', 'challenge', 'charSet', 'checked', 'className', 'content', 'contentEditable', 'crossOrigin', 'data', 'disabled', 'draggable', 'href', 'id', 'scrolling', 'spellCheck', 'tabIndex', 'target', 'type', 'wrap', 'onCopy', 'onCut', 'onPaste', 'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onFocus', 'onBlur', 'onChange', 'onInput', 'onInvalid', 'onSubmit', 'onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onPointerDown', 'onPointerMove', 'onPointerUp', 'onPointerCancel', 'onGotPointerCapture', 'onLostPointerCapture', 'onPointerEnter', 'onPointerLeave', 'onPointerOver', 'onPointerOut', 'onSelect', 'onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart', 'onScroll', 'onWheel', 'onAnimationStart', 'onAnimationEnd', 'onAnimationIteration', 'onTransitionEnd', 'onToggle']);
var makePropsFilter = function makePropsFilter() {
  var allPropsSet = new Set([]);

  for (var _len = arguments.length, propsSets = new Array(_len), _key = 0; _key < _len; _key++) {
    propsSets[_key] = arguments[_key];
  }

  for (var _i = 0, _propsSets = propsSets; _i < _propsSets.length; _i++) {
    var set = _propsSets[_i];
    set.forEach(function (el) {
      return allPropsSet.add(el);
    });
  }

  return function (props) {
    var propsCopy = {};

    for (var key in props) {
      if (allPropsSet.has(key)) propsCopy[key] = props[key];
    }

    return propsCopy;
  };
};

var styled = function styled(Component, filterComponentProps) {
  if (filterComponentProps === void 0) {
    filterComponentProps = function filterComponentProps(p) {
      return p;
    };
  }

  var templateFunction = makeTemplateFunction(Component, function (props) {
    return props;
  }, filterComponentProps); // it is impossible to infer the return value of attrMaker, it has to be typed explicitly

  templateFunction.attrs = function (attrMaker) {
    var transformProps = function transformProps(props) {
      return _extends({}, props, attrMaker instanceof Function ? attrMaker(props) : attrMaker);
    };

    return makeTemplateFunction(Component, transformProps, filterComponentProps);
  };

  return templateFunction;
};

styled.View = /*#__PURE__*/styled(View, /*#__PURE__*/makePropsFilter(viewProps, domProps));
styled.Text = /*#__PURE__*/styled(Text, /*#__PURE__*/makePropsFilter(textProps, domProps));
styled.Image = /*#__PURE__*/styled(Image, /*#__PURE__*/makePropsFilter(imageProps, domProps));
styled.ScrollView = /*#__PURE__*/styled(ScrollView, /*#__PURE__*/makePropsFilter(listProps, domProps));
styled.FlatList = /*#__PURE__*/styled(FlatList, /*#__PURE__*/makePropsFilter(listProps, domProps));
styled.SectionList = /*#__PURE__*/styled(SectionList, /*#__PURE__*/makePropsFilter(listProps, domProps));
styled.TouchableOpacity = /*#__PURE__*/styled(TouchableOpacity, /*#__PURE__*/makePropsFilter(pressableProps, domProps));
styled.TextInput = /*#__PURE__*/styled(TextInput, /*#__PURE__*/makePropsFilter(inputProps, viewProps, textProps, domProps));
styled.SafeAreaView = /*#__PURE__*/styled(SafeAreaView, /*#__PURE__*/makePropsFilter(viewProps, domProps));
var filterProps = /*#__PURE__*/makePropsFilter(viewProps, textProps, imageProps, listProps, pressableProps, inputProps, domProps);

export default styled;
export { ThemeContext, ThemeProvider, filterProps, setThemeContext, useColorAttribute, useLengthAttribute, useStyle, useTheme, withTheme };
//# sourceMappingURL=styled-native-components.esm.js.map
